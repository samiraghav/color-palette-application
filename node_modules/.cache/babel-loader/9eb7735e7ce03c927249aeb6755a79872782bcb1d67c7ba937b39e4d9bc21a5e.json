{"ast":null,"code":"// minimal multi-purpose interface\n\n// @requires utils color analyze\n\nconst chroma = require('../chroma');\nconst {\n  type\n} = require('../utils');\nconst {\n  pow\n} = Math;\nmodule.exports = function (colors) {\n  // constructor\n  let _mode = 'rgb';\n  let _nacol = chroma('#ccc');\n  let _spread = 0;\n  // const _fixed = false;\n  let _domain = [0, 1];\n  let _pos = [];\n  let _padding = [0, 0];\n  let _classes = false;\n  let _colors = [];\n  let _out = false;\n  let _min = 0;\n  let _max = 1;\n  let _correctLightness = false;\n  let _colorCache = {};\n  let _useCache = true;\n  let _gamma = 1;\n\n  // private methods\n\n  const setColors = function (colors) {\n    colors = colors || ['#fff', '#000'];\n    if (colors && type(colors) === 'string' && chroma.brewer && chroma.brewer[colors.toLowerCase()]) {\n      colors = chroma.brewer[colors.toLowerCase()];\n    }\n    if (type(colors) === 'array') {\n      // handle single color\n      if (colors.length === 1) {\n        colors = [colors[0], colors[0]];\n      }\n      // make a copy of the colors\n      colors = colors.slice(0);\n      // convert to chroma classes\n      for (let c = 0; c < colors.length; c++) {\n        colors[c] = chroma(colors[c]);\n      }\n      // auto-fill color position\n      _pos.length = 0;\n      for (let c = 0; c < colors.length; c++) {\n        _pos.push(c / (colors.length - 1));\n      }\n    }\n    resetCache();\n    return _colors = colors;\n  };\n  const getClass = function (value) {\n    if (_classes != null) {\n      const n = _classes.length - 1;\n      let i = 0;\n      while (i < n && value >= _classes[i]) {\n        i++;\n      }\n      return i - 1;\n    }\n    return 0;\n  };\n  let tMapLightness = t => t;\n  let tMapDomain = t => t;\n\n  // const classifyValue = function(value) {\n  //     let val = value;\n  //     if (_classes.length > 2) {\n  //         const n = _classes.length-1;\n  //         const i = getClass(value);\n  //         const minc = _classes[0] + ((_classes[1]-_classes[0]) * (0 + (_spread * 0.5)));  // center of 1st class\n  //         const maxc = _classes[n-1] + ((_classes[n]-_classes[n-1]) * (1 - (_spread * 0.5)));  // center of last class\n  //         val = _min + ((((_classes[i] + ((_classes[i+1] - _classes[i]) * 0.5)) - minc) / (maxc-minc)) * (_max - _min));\n  //     }\n  //     return val;\n  // };\n\n  const getColor = function (val, bypassMap) {\n    let col, t;\n    if (bypassMap == null) {\n      bypassMap = false;\n    }\n    if (isNaN(val) || val === null) {\n      return _nacol;\n    }\n    if (!bypassMap) {\n      if (_classes && _classes.length > 2) {\n        // find the class\n        const c = getClass(val);\n        t = c / (_classes.length - 2);\n      } else if (_max !== _min) {\n        // just interpolate between min/max\n        t = (val - _min) / (_max - _min);\n      } else {\n        t = 1;\n      }\n    } else {\n      t = val;\n    }\n\n    // domain map\n    t = tMapDomain(t);\n    if (!bypassMap) {\n      t = tMapLightness(t); // lightness correction\n    }\n\n    if (_gamma !== 1) {\n      t = pow(t, _gamma);\n    }\n    t = _padding[0] + t * (1 - _padding[0] - _padding[1]);\n    t = Math.min(1, Math.max(0, t));\n    const k = Math.floor(t * 10000);\n    if (_useCache && _colorCache[k]) {\n      col = _colorCache[k];\n    } else {\n      if (type(_colors) === 'array') {\n        //for i in [0.._pos.length-1]\n        for (let i = 0; i < _pos.length; i++) {\n          const p = _pos[i];\n          if (t <= p) {\n            col = _colors[i];\n            break;\n          }\n          if (t >= p && i === _pos.length - 1) {\n            col = _colors[i];\n            break;\n          }\n          if (t > p && t < _pos[i + 1]) {\n            t = (t - p) / (_pos[i + 1] - p);\n            col = chroma.interpolate(_colors[i], _colors[i + 1], t, _mode);\n            break;\n          }\n        }\n      } else if (type(_colors) === 'function') {\n        col = _colors(t);\n      }\n      if (_useCache) {\n        _colorCache[k] = col;\n      }\n    }\n    return col;\n  };\n  var resetCache = () => _colorCache = {};\n  setColors(colors);\n\n  // public interface\n\n  const f = function (v) {\n    const c = chroma(getColor(v));\n    if (_out && c[_out]) {\n      return c[_out]();\n    } else {\n      return c;\n    }\n  };\n  f.classes = function (classes) {\n    if (classes != null) {\n      if (type(classes) === 'array') {\n        _classes = classes;\n        _domain = [classes[0], classes[classes.length - 1]];\n      } else {\n        const d = chroma.analyze(_domain);\n        if (classes === 0) {\n          _classes = [d.min, d.max];\n        } else {\n          _classes = chroma.limits(d, 'e', classes);\n        }\n      }\n      return f;\n    }\n    return _classes;\n  };\n  f.domain = function (domain) {\n    if (!arguments.length) {\n      return _domain;\n    }\n    _min = domain[0];\n    _max = domain[domain.length - 1];\n    _pos = [];\n    const k = _colors.length;\n    if (domain.length === k && _min !== _max) {\n      // update positions\n      for (let d of Array.from(domain)) {\n        _pos.push((d - _min) / (_max - _min));\n      }\n    } else {\n      for (let c = 0; c < k; c++) {\n        _pos.push(c / (k - 1));\n      }\n      if (domain.length > 2) {\n        // set domain map\n        const tOut = domain.map((d, i) => i / (domain.length - 1));\n        const tBreaks = domain.map(d => (d - _min) / (_max - _min));\n        if (!tBreaks.every((val, i) => tOut[i] === val)) {\n          tMapDomain = t => {\n            if (t <= 0 || t >= 1) return t;\n            let i = 0;\n            while (t >= tBreaks[i + 1]) i++;\n            const f = (t - tBreaks[i]) / (tBreaks[i + 1] - tBreaks[i]);\n            const out = tOut[i] + f * (tOut[i + 1] - tOut[i]);\n            return out;\n          };\n        }\n      }\n    }\n    _domain = [_min, _max];\n    return f;\n  };\n  f.mode = function (_m) {\n    if (!arguments.length) {\n      return _mode;\n    }\n    _mode = _m;\n    resetCache();\n    return f;\n  };\n  f.range = function (colors, _pos) {\n    setColors(colors, _pos);\n    return f;\n  };\n  f.out = function (_o) {\n    _out = _o;\n    return f;\n  };\n  f.spread = function (val) {\n    if (!arguments.length) {\n      return _spread;\n    }\n    _spread = val;\n    return f;\n  };\n  f.correctLightness = function (v) {\n    if (v == null) {\n      v = true;\n    }\n    _correctLightness = v;\n    resetCache();\n    if (_correctLightness) {\n      tMapLightness = function (t) {\n        const L0 = getColor(0, true).lab()[0];\n        const L1 = getColor(1, true).lab()[0];\n        const pol = L0 > L1;\n        let L_actual = getColor(t, true).lab()[0];\n        const L_ideal = L0 + (L1 - L0) * t;\n        let L_diff = L_actual - L_ideal;\n        let t0 = 0;\n        let t1 = 1;\n        let max_iter = 20;\n        while (Math.abs(L_diff) > 1e-2 && max_iter-- > 0) {\n          (function () {\n            if (pol) {\n              L_diff *= -1;\n            }\n            if (L_diff < 0) {\n              t0 = t;\n              t += (t1 - t) * 0.5;\n            } else {\n              t1 = t;\n              t += (t0 - t) * 0.5;\n            }\n            L_actual = getColor(t, true).lab()[0];\n            return L_diff = L_actual - L_ideal;\n          })();\n        }\n        return t;\n      };\n    } else {\n      tMapLightness = t => t;\n    }\n    return f;\n  };\n  f.padding = function (p) {\n    if (p != null) {\n      if (type(p) === 'number') {\n        p = [p, p];\n      }\n      _padding = p;\n      return f;\n    } else {\n      return _padding;\n    }\n  };\n  f.colors = function (numColors, out) {\n    // If no arguments are given, return the original colors that were provided\n    if (arguments.length < 2) {\n      out = 'hex';\n    }\n    let result = [];\n    if (arguments.length === 0) {\n      result = _colors.slice(0);\n    } else if (numColors === 1) {\n      result = [f(0.5)];\n    } else if (numColors > 1) {\n      const dm = _domain[0];\n      const dd = _domain[1] - dm;\n      result = __range__(0, numColors, false).map(i => f(dm + i / (numColors - 1) * dd));\n    } else {\n      // returns all colors based on the defined classes\n      colors = [];\n      let samples = [];\n      if (_classes && _classes.length > 2) {\n        for (let i = 1, end = _classes.length, asc = 1 <= end; asc ? i < end : i > end; asc ? i++ : i--) {\n          samples.push((_classes[i - 1] + _classes[i]) * 0.5);\n        }\n      } else {\n        samples = _domain;\n      }\n      result = samples.map(v => f(v));\n    }\n    if (chroma[out]) {\n      result = result.map(c => c[out]());\n    }\n    return result;\n  };\n  f.cache = function (c) {\n    if (c != null) {\n      _useCache = c;\n      return f;\n    } else {\n      return _useCache;\n    }\n  };\n  f.gamma = function (g) {\n    if (g != null) {\n      _gamma = g;\n      return f;\n    } else {\n      return _gamma;\n    }\n  };\n  f.nodata = function (d) {\n    if (d != null) {\n      _nacol = chroma(d);\n      return f;\n    } else {\n      return _nacol;\n    }\n  };\n  return f;\n};\nfunction __range__(left, right, inclusive) {\n  let range = [];\n  let ascending = left < right;\n  let end = !inclusive ? right : ascending ? right + 1 : right - 1;\n  for (let i = left; ascending ? i < end : i > end; ascending ? i++ : i--) {\n    range.push(i);\n  }\n  return range;\n}","map":{"version":3,"names":["chroma","require","type","pow","Math","module","exports","colors","_mode","_nacol","_spread","_domain","_pos","_padding","_classes","_colors","_out","_min","_max","_correctLightness","_colorCache","_useCache","_gamma","setColors","brewer","toLowerCase","length","slice","c","push","resetCache","getClass","value","n","i","tMapLightness","t","tMapDomain","getColor","val","bypassMap","col","isNaN","min","max","k","floor","p","interpolate","f","v","classes","d","analyze","limits","domain","arguments","Array","from","tOut","map","tBreaks","every","out","mode","_m","range","_o","spread","correctLightness","L0","lab","L1","pol","L_actual","L_ideal","L_diff","t0","t1","max_iter","abs","padding","numColors","result","dm","dd","__range__","samples","end","asc","cache","gamma","g","nodata","left","right","inclusive","ascending"],"sources":["C:/Users/Sai/Desktop/REACT/youtube-extension/node_modules/chroma-js/src/generator/scale.js"],"sourcesContent":["// minimal multi-purpose interface\n\n// @requires utils color analyze\n\nconst chroma = require('../chroma');\nconst {type} = require('../utils');\n\nconst {pow} = Math;\n\nmodule.exports = function(colors) {\n\n    // constructor\n    let _mode = 'rgb';\n    let _nacol = chroma('#ccc');\n    let _spread = 0;\n    // const _fixed = false;\n    let _domain = [0, 1];\n    let _pos = [];\n    let _padding = [0,0];\n    let _classes = false;\n    let _colors = [];\n    let _out = false;\n    let _min = 0;\n    let _max = 1;\n    let _correctLightness = false;\n    let _colorCache = {};\n    let _useCache = true;\n    let _gamma = 1;\n\n    // private methods\n\n    const setColors = function(colors) {\n        colors = colors || ['#fff', '#000'];\n        if (colors && type(colors) === 'string' && chroma.brewer &&\n            chroma.brewer[colors.toLowerCase()]) {\n            colors = chroma.brewer[colors.toLowerCase()];\n        }\n        if (type(colors) === 'array') {\n            // handle single color\n            if (colors.length === 1) {\n                colors = [colors[0], colors[0]];\n            }\n            // make a copy of the colors\n            colors = colors.slice(0);\n            // convert to chroma classes\n            for (let c=0; c<colors.length; c++) {\n                colors[c] = chroma(colors[c]);\n            }\n            // auto-fill color position\n            _pos.length = 0;\n            for (let c=0; c<colors.length; c++) {\n                _pos.push(c/(colors.length-1));\n            }\n        }\n        resetCache();\n        return _colors = colors;\n    };\n\n    const getClass = function(value) {\n        if (_classes != null) {\n            const n = _classes.length-1;\n            let i = 0;\n            while (i < n && value >= _classes[i]) {\n                i++;\n            }\n            return i-1;\n        }\n        return 0;\n    };\n\n    let tMapLightness = t => t;\n    let tMapDomain = t => t;\n\n    // const classifyValue = function(value) {\n    //     let val = value;\n    //     if (_classes.length > 2) {\n    //         const n = _classes.length-1;\n    //         const i = getClass(value);\n    //         const minc = _classes[0] + ((_classes[1]-_classes[0]) * (0 + (_spread * 0.5)));  // center of 1st class\n    //         const maxc = _classes[n-1] + ((_classes[n]-_classes[n-1]) * (1 - (_spread * 0.5)));  // center of last class\n    //         val = _min + ((((_classes[i] + ((_classes[i+1] - _classes[i]) * 0.5)) - minc) / (maxc-minc)) * (_max - _min));\n    //     }\n    //     return val;\n    // };\n\n    const getColor = function(val, bypassMap) {\n        let col, t;\n        if (bypassMap == null) { bypassMap = false; }\n        if (isNaN(val) || (val === null)) { return _nacol; }\n        if (!bypassMap) {\n            if (_classes && (_classes.length > 2)) {\n                // find the class\n                const c = getClass(val);\n                t = c / (_classes.length-2);\n            } else if (_max !== _min) {\n                // just interpolate between min/max\n                t = (val - _min) / (_max - _min);\n            } else {\n                t = 1;\n            }\n        } else {\n            t = val;\n        }\n\n        // domain map\n        t = tMapDomain(t);\n\n        if (!bypassMap) {\n            t = tMapLightness(t);  // lightness correction\n        }\n\n        if (_gamma !== 1) { t = pow(t, _gamma); }\n\n        t = _padding[0] + (t * (1 - _padding[0] - _padding[1]));\n\n        t = Math.min(1, Math.max(0, t));\n\n        const k = Math.floor(t * 10000);\n\n        if (_useCache && _colorCache[k]) {\n            col = _colorCache[k];\n        } else {\n            if (type(_colors) === 'array') {\n                //for i in [0.._pos.length-1]\n                for (let i=0; i<_pos.length; i++) {\n                    const p = _pos[i];\n                    if (t <= p) {\n                        col = _colors[i];\n                        break;\n                    }\n                    if ((t >= p) && (i === (_pos.length-1))) {\n                        col = _colors[i];\n                        break;\n                    }\n                    if (t > p && t < _pos[i+1]) {\n                        t = (t-p)/(_pos[i+1]-p);\n                        col = chroma.interpolate(_colors[i], _colors[i+1], t, _mode);\n                        break;\n                    }\n                }\n            } else if (type(_colors) === 'function') {\n                col = _colors(t);\n            }\n            if (_useCache) { _colorCache[k] = col; }\n        }\n        return col;\n    };\n\n    var resetCache = () => _colorCache = {};\n\n    setColors(colors);\n\n    // public interface\n\n    const f = function(v) {\n        const c = chroma(getColor(v));\n        if (_out && c[_out]) { return c[_out](); } else { return c; }\n    };\n\n    f.classes = function(classes) {\n        if (classes != null) {\n            if (type(classes) === 'array') {\n                _classes = classes;\n                _domain = [classes[0], classes[classes.length-1]];\n            } else {\n                const d = chroma.analyze(_domain);\n                if (classes === 0) {\n                    _classes = [d.min, d.max];\n                } else {\n                    _classes = chroma.limits(d, 'e', classes);\n                }\n            }\n            return f;\n        }\n        return _classes;\n    };\n\n\n    f.domain = function(domain) {\n        if (!arguments.length) {\n            return _domain;\n        }\n        _min = domain[0];\n        _max = domain[domain.length-1];\n        _pos = [];\n        const k = _colors.length;\n        if ((domain.length === k) && (_min !== _max)) {\n            // update positions\n            for (let d of Array.from(domain)) {\n                _pos.push((d-_min) / (_max-_min));\n            }\n        } else {\n            for (let c=0; c<k; c++) {\n                _pos.push(c/(k-1));\n            }\n            if (domain.length > 2) {\n                // set domain map\n                const tOut = domain.map((d,i) => i/(domain.length-1));\n                const tBreaks = domain.map(d => (d - _min) / (_max - _min));\n                if (!tBreaks.every((val, i) => tOut[i] === val)) {\n                    tMapDomain = (t) => {\n                        if (t <= 0 || t >= 1) return t;\n                        let i = 0;\n                        while (t >= tBreaks[i+1]) i++;\n                        const f = (t - tBreaks[i]) / (tBreaks[i+1] - tBreaks[i]);\n                        const out = tOut[i] + f * (tOut[i+1] - tOut[i])\n                        return out;\n                    }\n                }\n\n            }\n        }\n        _domain = [_min, _max];\n        return f;\n    };\n\n    f.mode = function(_m) {\n        if (!arguments.length) {\n            return _mode;\n        }\n        _mode = _m;\n        resetCache();\n        return f;\n    };\n\n    f.range = function(colors, _pos) {\n        setColors(colors, _pos);\n        return f;\n    };\n\n    f.out = function(_o) {\n        _out = _o;\n        return f;\n    };\n\n    f.spread = function(val) {\n        if (!arguments.length) {\n            return _spread;\n        }\n        _spread = val;\n        return f;\n    };\n\n    f.correctLightness = function(v) {\n        if (v == null) { v = true; }\n        _correctLightness = v;\n        resetCache();\n        if (_correctLightness) {\n            tMapLightness = function(t) {\n                const L0 = getColor(0, true).lab()[0];\n                const L1 = getColor(1, true).lab()[0];\n                const pol = L0 > L1;\n                let L_actual = getColor(t, true).lab()[0];\n                const L_ideal = L0 + ((L1 - L0) * t);\n                let L_diff = L_actual - L_ideal;\n                let t0 = 0;\n                let t1 = 1;\n                let max_iter = 20;\n                while ((Math.abs(L_diff) > 1e-2) && (max_iter-- > 0)) {\n                    (function() {\n                        if (pol) { L_diff *= -1; }\n                        if (L_diff < 0) {\n                            t0 = t;\n                            t += (t1 - t) * 0.5;\n                        } else {\n                            t1 = t;\n                            t += (t0 - t) * 0.5;\n                        }\n                        L_actual = getColor(t, true).lab()[0];\n                        return L_diff = L_actual - L_ideal;\n                    })();\n                }\n                return t;\n            };\n        } else {\n            tMapLightness = t => t;\n        }\n        return f;\n    };\n\n    f.padding = function(p) {\n        if (p != null) {\n            if (type(p) === 'number') {\n                p = [p,p];\n            }\n            _padding = p;\n            return f;\n        } else {\n            return _padding;\n        }\n    };\n\n    f.colors = function(numColors, out) {\n        // If no arguments are given, return the original colors that were provided\n        if (arguments.length < 2) { out = 'hex'; }\n        let result = [];\n\n        if (arguments.length === 0) {\n            result = _colors.slice(0);\n\n        } else if (numColors === 1) {\n            result = [f(0.5)];\n\n        } else if (numColors > 1) {\n            const dm = _domain[0];\n            const dd = _domain[1] - dm;\n            result = __range__(0, numColors, false).map(i => f( dm + ((i/(numColors-1)) * dd) ));\n\n        } else { // returns all colors based on the defined classes\n            colors = [];\n            let samples = [];\n            if (_classes && (_classes.length > 2)) {\n                for (let i = 1, end = _classes.length, asc = 1 <= end; asc ? i < end : i > end; asc ? i++ : i--) {\n                    samples.push((_classes[i-1]+_classes[i])*0.5);\n                }\n            } else {\n                samples = _domain;\n            }\n            result = samples.map(v => f(v));\n        }\n\n        if (chroma[out]) {\n            result = result.map(c => c[out]());\n        }\n        return result;\n    };\n\n    f.cache = function(c) {\n        if (c != null) {\n            _useCache = c;\n            return f;\n        } else {\n            return _useCache;\n        }\n    };\n\n    f.gamma = function(g) {\n        if (g != null) {\n            _gamma = g;\n            return f;\n        } else {\n            return _gamma;\n        }\n    };\n\n    f.nodata = function(d) {\n        if (d != null) {\n            _nacol = chroma(d);\n            return f;\n        } else {\n            return _nacol;\n        }\n    };\n\n    return f;\n};\n\nfunction __range__(left, right, inclusive) {\n  let range = [];\n  let ascending = left < right;\n  let end = !inclusive ? right : ascending ? right + 1 : right - 1;\n  for (let i = left; ascending ? i < end : i > end; ascending ? i++ : i--) {\n    range.push(i);\n  }\n  return range;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}